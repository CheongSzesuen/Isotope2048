<template>
	<div onswipe="move" class="bg">
	  <!--背景+按钮-->
	  <div class="bg" if="{{dark}}">
		<img src="/common/Dark.png" class="bg"/>
		<!-- 返回按钮(暗色) -->
		<img src="/common/Back_B_rgb.png" style="position: absolute;left: 6px;top: 6px;" @click="exit"/>
		<!-- 设置按钮(暗色) -->
		<img src="/common/info_b.png" style="position: absolute;left: 258px;top: 6px;" @click="openMenu"/>
		<img src="/common/Reset_B.png" style="position: absolute;left: 6px;top: 402px;" @click="new_game" />
		<img src="/common/Undo_B.png" style="position: absolute;left: 258px;top: 402px;" @click="chcb" />
		<!--积分版-->
		<text class="score">{{ sco }}</text>
		<text class="score" style="font-size: 20px;top: 12px;">{{time}}</text>
	  </div>
	  <div class="bg" else>
		<img src="/common/Light.png" class="bg"/>
		<!-- 返回按钮(亮色) -->
		<img src="/common/back.png" style="position: absolute;left: 6px;top: 6px;" @click="exit"/>
		<!-- 设置按钮(亮色) -->
		<img src="/common/info.png" style="position: absolute;left: 258px;top: 6px;" @click="openMenu"/>
		<img src="/common/Reset.png" style="position: absolute;left: 6px;top: 402px;" @click="new_game" />
		<img src="/common/Undo.png" style="position: absolute;left: 258px;top: 402px;" @click="chcb" />
		<!--积分版-->
		<text class="score" style="color: rgba(0, 0, 0, 0.4);">{{ sco }}</text>
		<text class="score" style="font-size: 20px;top: 12px;color: rgba(0, 0, 0, 0.6);">{{time}}</text>
	  </div>
	  
	  <!--游戏区域-->
	  <div style="position: absolute;left: 14px;top: 86px;width: 308px;height: 308px;padding-top: 8px;padding-left:8px;display: flex;flex-wrap: wrap;" >
		<text class="square" for="{{blocks}}" style="background-color: {{ bgc[md[$item]] }};border: {{(!!md[$item])*3}}px;font-size: {{md[$item]>1000?16:32}}px;" id="b{{$item}}" if="{{!dark}}">
		  {{ getElementSymbol(md[$item]) }}
		  <span if="{{ unstable[$item] > 0 }}" class="unstable-count">{{ unstable[$item] }}</span>
		</text>
		<text class="square" for="{{blocks}}" style="color: {{ bgc[md[$item]] }};background-color: {{ md[$item] ? 'rgba(0, 0, 0, 0.36)' : '#00000000' }};border: {{(!!md[$item])*3}}px;font-size: {{md[$item]>1000?16:32}}px;" id="b{{$item}}" else >
		  {{ getElementSymbol(md[$item]) }}
		  <span if="{{ unstable[$item] > 0 }}" class="unstable-count">{{ unstable[$item] }}</span>
		</text>
	  </div>
	</div>
  </template>
  
  <script>
  import prompt from "@system.prompt";
import storage from "@system.storage";
import vibrator from "@system.vibrator"
import router from "@system.router";

// 元素符号映射表
const elements = {
  2: "H", // 氢
  4: "He", // 氦
  8: "Be", // 铍
  16: "O", // 氧
  32: "P", // 磷
  64: "Ni", // 镍
  128: "U", // 铀
  256: "Pu", // 钚
  512: "Fm", // 镄
  1024: "Og", // 鿫
  2048: "∞" // ∞无穷-宇宙坍缩
}

// 不稳定元素配置（衰变机制）
const unstableConfig = {
  8: 8, // 铍，8次移动后衰变
  32: 24, // 磷，24次移动后衰变
  128: 96, // 铀，96次移动后衰变
  256: 192, // 钚，192次移动后衰变
  512: 384, // 镄，384次移动后衰变
  1024: 768 // 鿫，768次移动后衰变
}

function isUnstable(value) {
  return unstableConfig[value] !== undefined
}

let sc = 0,
  ls,
  lhs,
  board = Array(4),
  added = Array(4),
  over = 0,
  lm = Array(4),
  that,
  decayedTiles = []; // 记录衰变的方块信息

for (let i = 0; i < 4; i++) {
  lm[i] = new Array(4);
  board[i] = new Array(4);
  added[i] = new Array(4);
  for (let j = 0; j < 4; j++) {
    board[i][j] = {value: 0, unstable: 0};
    lm[i][j] = {value: 0, unstable: 0};
  }
}

export default {
  public: {
    blocks: ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15"],
    md: Array(16),
    unstable: Array(16).fill(0),
    hsc: 0,
    sco: sc,
    bgc: {},
    ch: 0,
    dark: true,
	time: "00:00"
  },
  
  exit() {
    router.back();
  },
  
  openMenu() {
    router.push({uri: "pages/settings"});
  },
  
  getElementSymbol(value) {
    return elements[value] || ""
  },
  
  onInit() {
    // 优先读取暗色模式设置
    storage.get({
      key: "dark",
      success: (data) => {
        this.dark = data === "dark";
      },
      fail: () => {
        this.dark = true; // 默认暗色模式
      }
    });
    
    that = this;
    // 初始化时间
    this.updateTime()
    
    // 设置定时器每分钟更新一次
    setInterval(() => this.updateTime(), 1000)
	
    // 颜色初始化
    let tempc =
      "rgba(0,0,0,0) #EFE5DA #F0E0C9 #fcb477 #ff9c61 #ff865d #ff6a38 #ebcf71 #ebcc5f #ebc94f #ebc53f #ebc22c #F2B6B6 #E8ED51 #FFE3FB #E8FF8C #FFDEC9 #F5A433 #E6109B #96C4E6 #E560CD".split(" ");
    tempc.forEach((a, index) => {
      this.bgc[2 ** index] = a;
    });
    this.bgc[""] = "#00000000";
    
    storage.get({
      key: "score",
      success: (data) => {
        if (data) {
          let o = JSON.parse(data);
          board = o.map.map((row) =>
            row.map((cell) => {
              if (typeof cell === "object") return cell;
              return {value: cell, unstable: 0}
            })
          );
          this.updateUnstableDisplay();
          rm0(board);
          this.hsc = o.hs;
          this.sco = o.sc
          this.ch = o.ch || 0;
          this.dark = typeof o.dark !== 'undefined' ? o.dark : this.dark;
          
          // 恢复衰变方块数据
          if (o.decayedTiles) {
            decayedTiles = o.decayedTiles;
          }
          
          // 恢复撤销数据
          if (o.lm) {
            for (let i = 0; i < 4; i++) {
              for (let j = 0; j < 4; j++) {
                lm[i][j] = o.lm[i][j] ? {...o.lm[i][j]} : {value: 0, unstable: 0};
              }
            }
            ls = o.ls;
            lhs = o.lhs;
          }
        } else {
          this.new_game();
        }
      },
      fail: () => {
        this.new_game();
      }
    });
    clear(added)
  },
  
  onShow() {
    // 每次页面显示时检查最新设置
    storage.get({
      key: "dark",
      success: (data) => {
        this.dark = data === "dark";
      }
    });
  },
  
  updateUnstableDisplay() {
    let index = 0;
    for (let i = 0; i < 4; i++) {
      for (let j = 0; j < 4; j++) {
        this.unstable[index] = board[i][j]?.unstable || 0;
        index++;
      }
    }
  },
  updateTime() {
    const now = new Date()
    this.time = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`
  },
  chcb() {
    if (this.ch == 1) {
      this.hsc = lhs;
      this.sco = ls;

      // 恢复衰变的方块
      decayedTiles.forEach((tile) => {
        board[tile.x][tile.y] = {
          value: tile.originalValue,
          unstable: tile.originalUnstable || 0
        }
      });
      decayedTiles = [];

      // 恢复游戏状态
      for (let i = 0; i < 4; i++) {
        for (let j = 0; j < 4; j++) {
          board[i][j] = lm[i][j] ? {...lm[i][j]} : {value: 0, unstable: 0};
        }
      }

      this.updateUnstableDisplay();
      rm0(board);
      over = 0;
      this.save();
      this.ch = 0;
    } else {
      prompt.showToast({
        message: "不能再撤啦",
        duration: 1000
      });
    }
  },
  
  new_game() {
    backup();
    newgame();
    this.sco = 0;
    this.save();
  },
  
  move(eve) {
    backup(); // 在移动前备份状态
    mo(eve.direction);
    if (over) {
      prompt.showToast({
        message: "Gameover!",
        duration: 2000,
      });
      // 游戏结束时触发震动
      vibrator.vibrate({
        mode: "long"
      });
    }
    if (this.sco > this.hsc) {
      this.hsc = this.sco;
    }
    this.save();
  },
  
  save() {
    let o = {
      map: board.map((row) =>
        row.map((cell) => {
          if (!cell) return 0;
          return {
            value: cell.value,
            unstable: cell.unstable || 0
          }
        })
      ),
      hs: this.hsc,
      sc: this.sco,
      dark: this.dark,
      ch: this.ch,
      // 保存撤销数据
      lm: lm.map((row) =>
        row.map((cell) => {
          if (!cell) return 0;
          return {
            value: cell.value,
            unstable: cell.unstable || 0
          }
        })
      ),
      ls: ls,
      lhs: lhs,
      // 保存衰变方块数据
      decayedTiles: decayedTiles
    };
    storage.set({
      key: "score",
      value: JSON.stringify(o),
      fail: (data, code) => {
        console.error(`保存游戏数据失败: ${code}`);
      }
    });
  }
};

// 以下是游戏核心逻辑函数
function rm0(sm) {
  let a = 0;
  for (let i = 0; i < 4; i++) {
    for (let j = 0; j < 4; j++) {
      if (!sm[i][j] || sm[i][j].value === 0) {
        that.md[a] = "";
      } else {
        that.md[a] = sm[i][j].value;
      }
      a++;
    }
  }
  that.updateUnstableDisplay();
}

function clear(m) {
  for (let i = 0; i < 4; i++) {
    m[i].fill(0);
  }
}

function newgame() {
  over = 0;
  for (let i = 0; i < 4; i++) {
    for (let j = 0; j < 4; j++) {
      board[i][j] = {value: 0, unstable: 0};
    }
  }
  newblock();
  newblock();
  rm0(board);
  decayedTiles = [];
}

function rand_num() {
  return Math.floor(Math.random() * 1000);
}

function newblock() {
  for (var a = 3, b = rand_num() % 4, c = rand_num() % 4, d = 50 < rand_num() % 100 ? 4 : 2; 0 < a;) {
    if (!board[b][c] || board[b][c].value === 0) {
      board[b][c] = {
        value: d,
        unstable: isUnstable(d) ? unstableConfig[d] : 0
      };
      return;
    }
    b = rand_num() % 4;
    c = rand_num() % 4;
    a--;
  }
  
  // 检查游戏是否结束
  checkGameOver();
}

function mo(dir) {
  // 先检查是否还有移动可能
  if (!canMoveLeft(board) && !canMoveRight(board) && !canMoveUp(board) && !canMoveDown(board)) {
    over = 1;
    rm0(board);
    // 游戏结束时触发震动
    vibrator.vibrate({
      mode: "long"
    });
    return false;
  }

  let moved = false;

  switch (dir.toLowerCase()) {
    case "left":
      moved = moveleft();
      break;
    case "right":
      moved = moveright();
      break;
    case "up":
      moved = moveup();
      break;
    case "down":
      moved = movedown();
      break;
  }

  if (moved) {
    // 更新不稳定方块计数器并处理衰变
    for (let i = 0; i < 4; i++) {
      for (let j = 0; j < 4; j++) {
        if (board[i][j] && board[i][j].unstable > 0) {
          board[i][j].unstable--;
          if (board[i][j].unstable === 0) {
            decayElement(i, j); // 调用衰变函数
          }
        }
      }
    }

    clear(added);
    newblock();
    rm0(board);
  }

  return moved;
}

// 游戏结束检查函数
function checkGameOver() {
  // 检查是否有空格
  for (let i = 0; i < 4; i++) {
    for (let j = 0; j < 4; j++) {
      if (!board[i][j] || board[i][j].value === 0) {
        over = 0;
        return;
      }
    }
  }

  // 检查是否有可合并的相邻方块
  for (let i = 0; i < 4; i++) {
    for (let j = 0; j < 4; j++) {
      const current = board[i][j];
      if (!current) continue;

      // 检查右侧
      if (j < 3 && board[i][j + 1] && board[i][j + 1].value === current.value) {
        over = 0;
        return;
      }

      // 检查下方
      if (i < 3 && board[i + 1][j] && board[i + 1][j].value === current.value) {
        over = 0;
        return;
      }
    }
  }

  // 如果没有空格且没有可合并的方块，游戏结束
  over = 1;
}

// 元素衰变函数
function decayElement(x, y) {
  const currentValue = board[x][y].value;
  const currentUnstable = board[x][y].unstable;
  const possibleDecays = [];

  // 收集所有比当前元素小的元素作为可能的衰变结果
  for (const value in elements) {
    const numValue = parseInt(value);
    if (numValue < currentValue && numValue !== currentValue) {
      possibleDecays.push(numValue);
    }
  }

  if (possibleDecays.length === 0) {
    board[x][y] = {value: 0, unstable: 0};
    return;
  }

  // 计算权重：值越小权重越高（概率越大）
  const weights = possibleDecays.map((v) => 1 / (v / 2));
  const totalWeight = weights.reduce((a, b) => a + b, 0);

  // 根据权重随机选择衰变结果
  let random = Math.random() * totalWeight;
  let selectedIndex = 0;
  for (let i = 0; i < weights.length; i++) {
    random -= weights[i];
    if (random <= 0) {
      selectedIndex = i;
      break;
    }
  }

  let decayValue = possibleDecays[selectedIndex];

  // 检查周围是否有相同元素
  const directions = [
    [-1, 0],
    [1, 0],
    [0, -1],
    [0, 1]
  ];
  let hasSameNeighbor = false;

  for (const [dx, dy] of directions) {
    const nx = x + dx;
    const ny = y + dy;

    if (
      nx >= 0 &&
      nx < 4 &&
      ny >= 0 &&
      ny < 4 &&
      board[nx][ny] &&
      board[nx][ny].value === decayValue
    ) {
      hasSameNeighbor = true;
      break;
    }
  }

  // 如果有相同邻居，降为最小元素(氢)
  if (hasSameNeighbor) {
    decayValue = 2; // 氢
  }

  // 记录衰变前的状态（用于撤销）
  decayedTiles.push({
    x: x,
    y: y,
    originalValue: currentValue,
    originalUnstable: currentUnstable,
    decayedValue: decayValue
  });

  // 触发震动
  vibrator.vibrate({
    mode: "short"
  });

  // 更新方块
  board[x][y] = {
    value: decayValue,
    unstable: isUnstable(decayValue) ? unstableConfig[decayValue] : 0
  };

  // 提示信息
  prompt.showToast({
    message: `${elements[currentValue]}衰变为${elements[decayValue]}!`,
    duration: 500
  });

  // 分数调整为衰变值的10%
  that.sco += Math.floor(decayValue * 0.1);
}

function backup() {
  // 清空之前的衰变记录
  decayedTiles = [];

  // 备份当前状态
  for (let i = 0; i < 4; i++) {
    for (let j = 0; j < 4; j++) {
      lm[i][j] = board[i][j] ? {...board[i][j]} : {value: 0, unstable: 0};
    }
  }
  ls = that.sco;
  lhs = that.hsc;
  that.ch = 1;
}

// 移动方向相关函数
function moveleft() {
  let moved = false;
  for (let a = 0; a < 4; a++) {
    for (let b = 1; b < 4; b++) {
      const current = board[a][b];
      if (current && current.value !== 0) {
        for (let c = 0; c < b; c++) {
          const target = board[a][c];

          if ((!target || target.value === 0) && noBlockHorizontal(a, c, b, board)) {
            board[a][c] = current;
            board[a][b] = {value: 0, unstable: 0};
            moved = true;
            break;
          } else if (
            target &&
            target.value === current.value &&
            noBlockHorizontal(a, c, b, board) &&
            0 == added[a][c]
          ) {
            const newValue = target.value * 2;
            board[a][c] = {
              value: newValue,
              unstable: isUnstable(newValue) ? unstableConfig[newValue] : 0
            };

            let bonus = 0;
            if (current.unstable) bonus += current.unstable * 5;
            if (target.unstable) bonus += target.unstable * 5;
            that.sco += newValue + bonus;

            board[a][b] = {value: 0, unstable: 0};
            added[a][c] = 1;
            moved = true;
            break;
          }
        }
      }
    }
  }
  return moved;
}

function moveright() {
  let moved = false;
  for (let a = 0; a < 4; a++) {
    for (let b = 2; b >= 0; b--) {
      const current = board[a][b];
      if (current && current.value !== 0) {
        for (let c = 3; c > b; c--) {
          const target = board[a][c];

          if ((!target || target.value === 0) && noBlockHorizontal(a, b, c, board)) {
            board[a][c] = current;
            board[a][b] = {value: 0, unstable: 0};
            moved = true;
            break;
          } else if (
            target &&
            target.value === current.value &&
            noBlockHorizontal(a, b, c, board) &&
            0 == added[a][c]
          ) {
            const newValue = target.value * 2;
            board[a][c] = {
              value: newValue,
              unstable: isUnstable(newValue) ? unstableConfig[newValue] : 0
            };

            let bonus = 0;
            if (current.unstable) bonus += current.unstable * 5;
            if (target.unstable) bonus += target.unstable * 5;
            that.sco += newValue + bonus;

            board[a][b] = {value: 0, unstable: 0};
            added[a][c] = 1;
            moved = true;
            break;
          }
        }
      }
    }
  }
  return moved;
}

function moveup() {
  let moved = false;
  for (let a = 0; a < 4; a++) {
    for (let b = 1; b < 4; b++) {
      const current = board[b][a];
      if (current && current.value !== 0) {
        for (let c = 0; c < b; c++) {
          const target = board[c][a];

          if ((!target || target.value === 0) && noBlockVertical(a, c, b, board)) {
            board[c][a] = current;
            board[b][a] = {value: 0, unstable: 0};
            moved = true;
            break;
          } else if (
            target &&
            target.value === current.value &&
            noBlockVertical(a, c, b, board) &&
            0 == added[c][a]
          ) {
            const newValue = target.value * 2;
            board[c][a] = {
              value: newValue,
              unstable: isUnstable(newValue) ? unstableConfig[newValue] : 0
            };

            let bonus = 0;
            if (current.unstable) bonus += current.unstable * 5;
            if (target.unstable) bonus += target.unstable * 5;
            that.sco += newValue + bonus;

            board[b][a] = {value: 0, unstable: 0};
            added[c][a] = 1;
            moved = true;
            break;
          }
        }
      }
    }
  }
  return moved;
}

function movedown() {
  let moved = false;
  for (let a = 0; a < 4; a++) {
    for (let b = 2; b >= 0; b--) {
      const current = board[b][a];
      if (current && current.value !== 0) {
        for (let c = 3; c > b; c--) {
          const target = board[c][a];

          if ((!target || target.value === 0) && noBlockVertical(a, b, c, board)) {
            board[c][a] = current;
            board[b][a] = {value: 0, unstable: 0};
            moved = true;
            break;
          } else if (
            target &&
            target.value === current.value &&
            noBlockVertical(a, b, c, board) &&
            0 == added[c][a]
          ) {
            const newValue = target.value * 2;
            board[c][a] = {
              value: newValue,
              unstable: isUnstable(newValue) ? unstableConfig[newValue] : 0
            };

            let bonus = 0;
            if (current.unstable) bonus += current.unstable * 5;
            if (target.unstable) bonus += target.unstable * 5;
            that.sco += newValue + bonus;

            board[b][a] = {value: 0, unstable: 0};
            added[c][a] = 1;
            moved = true;
            break;
          }
        }
      }
    }
  }
  return moved;
}

// 辅助函数
function canMoveLeft(a) {
  for (let b = 0; b < 4; b++) {
    for (let c = 0; c < 4; c++) {
      const cell = a[b][c];
      if (cell && cell.value !== 0 && c != 0) {
        const left = a[b][c - 1];
        if (!left || left.value === 0 || left.value === cell.value) {
          return true;
        }
      }
    }
  }
  return false;
}

function canMoveRight(a) {
  for (let b = 0; b < 4; b++) {
    for (let c = 0; c < 4; c++) {
      const cell = a[b][c];
      if (cell && cell.value !== 0 && c != 3) {
        const right = a[b][c + 1];
        if (!right || right.value === 0 || right.value === cell.value) {
          return true;
        }
      }
    }
  }
  return false;
}

function canMoveUp(a) {
  for (let b = 0; b < 4; b++) {
    for (let c = 0; c < 4; c++) {
      const cell = a[b][c];
      if (cell && cell.value !== 0 && b != 0) {
        const up = a[b - 1][c];
        if (!up || up.value === 0 || up.value === cell.value) {
          return true;
        }
      }
    }
  }
  return false;
}

function canMoveDown(a) {
  for (let b = 0; b < 4; b++) {
    for (let c = 0; c < 4; c++) {
      const cell = a[b][c];
      if (cell && cell.value !== 0 && b != 3) {
        const down = a[b + 1][c];
        if (!down || down.value === 0 || down.value === cell.value) {
          return true;
        }
      }
    }
  }
  return false;
}

function noBlockHorizontal(a, b, c, d) {
  for (b += 1; b < c; b++)
    if (d[a][b] && d[a][b].value !== 0) return false;
  return true;
}

function noBlockVertical(a, b, c, d) {
  for (b += 1; b < c; b++)
    if (d[b][a] && d[b][a].value !== 0) return false;
  return true;
}
  </script>
  
  <style>
  text {
	font-weight: bold;
	text-align: center;
  }
  .score {
	position: absolute;
	left: 78px;
	top: 441px;
	width: 180px;
	height: 32px;
	font-size: 24px;
	text-align: center;
	color: rgba(255, 255, 255, 0.6);
  }
  .square {
	width: 68px;
	height: 68px;
	margin-top: 4px;
	margin-left: 4px;
	border-radius: 20px;
	color: #59503f;
	border: 0px solid rgba(255, 255, 255, 0.06);
	position: relative;
  }
  .unstable-count {
	position: absolute;
	bottom: 2px;
	right: 2px;
	font-size: 10px;
	color: red;
	font-weight: bold;
  }
  .bg {
	position: absolute;
	width: 336px;
	height: 480px;
	background-color: black;
  }

  .time-text {
	position: absolute;
	left: 150px;
	top: 12px;
	font-size: 20px;
	color: white;
	text-align: center;
	width: 36px;
}
  </style>